<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R on Dr Graeme L. Hickey</title>
    <link>http://www.glhickey.com/categories/r/index.xml</link>
    <description>Recent content in R on Dr Graeme L. Hickey</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Graeme L. Hickey</copyright>
    <atom:link href="/categories/r/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using joineRML v0.1.1</title>
      <link>http://www.glhickey.com/post/2017-02-17-using-joinerml/</link>
      <pubDate>Fri, 17 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.glhickey.com/post/2017-02-17-using-joinerml/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;



&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;

&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

&lt;p&gt;The &lt;code&gt;joineRML&lt;/code&gt; package implements methods for analyzing data from &lt;em&gt;multiple&lt;/em&gt; longitudinal studies in which the responses from each subject consists of time-sequences of repeated measurements and a possibly censored time-to-event outcome. The modelling framework for the repeated measurements is the multivariate linear mixed effects model. The model for the time-to-event outcome is a Cox proportional hazards model with log-Gaussian frailty. Stochastic dependence is captured by allowing the Gaussian random effects of the linear model to be correlated with the frailty term of the Cox proportional hazards model. For full details of the model, please consult the technical vignette by running&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;vignette(&amp;quot;technical&amp;quot;, package = &amp;quot;joineRML&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;heart-valve-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Heart valve data&lt;/h1&gt;
&lt;div id=&#34;data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data&lt;/h2&gt;
&lt;p&gt;The simplest way to explain the concepts of the package is through an example. &lt;code&gt;joineRML&lt;/code&gt; comes with the data set &lt;code&gt;heart.valve&lt;/code&gt;. Details of this data can be found in the help file by running the command&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;help(&amp;quot;heart.valve&amp;quot;, package = &amp;quot;joineRML&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This data is in so-called &lt;em&gt;long&lt;/em&gt; or &lt;em&gt;unbalanced&lt;/em&gt; format:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;joineRML&amp;quot;)
data(&amp;quot;heart.valve&amp;quot;)
head(heart.valve)
##   num sex      age      time    fuyrs status grad log.grad   lvmi log.lvmi
## 1   1   0 75.06027 0.0109589 4.956164      0   10 2.302585 118.98 4.778955
## 2   1   0 75.06027 3.6794520 4.956164      0   10 2.302585 118.98 4.778955
## 3   1   0 75.06027 4.6958900 4.956164      0   10 2.302585 137.63 4.924569
## 4   2   0 45.79452 6.3643840 9.663014      0   14 2.639057 114.93 4.744323
## 5   2   0 45.79452 7.3041100 9.663014      0    9 2.197225 109.80 4.698661
## 6   2   0 45.79452 8.3013700 9.663014      0   12 2.484907 157.40 5.058790
##   ef  bsa lvh prenyha redo size con.cabg creat dm acei lv emergenc hc
## 1 93 1.77   1       3    0   27        1   103  0    1  1        0  0
## 2 93 1.77   1       3    0   27        1   103  0    1  1        0  0
## 3 93 1.77   1       3    0   27        1   103  0    1  1        0  0
## 4 68 1.92   1       1    1   22        0    76  0    0  2        0  0
## 5 70 1.92   1       1    1   22        0    76  0    0  2        0  0
## 6 56 1.92   1       1    1   22        0    76  0    0  2        0  0
##   sten.reg.mix              hs
## 1            1 Stentless valve
## 2            1 Stentless valve
## 3            1 Stentless valve
## 4            1       Homograft
## 5            1       Homograft
## 6            1       Homograft&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The data refer to 256 patients and are stored in the unbalanced format, which is convenient here because measurement times were unique to each subject. The data are stored as a single R object, &lt;code&gt;heart.valve&lt;/code&gt;, which is a data frame of dimension 988 by 25. The average number of repeated measurements per subject is therefore 988/256 = 3.86. As with any unbalanced data set, values of time-constant variables are repeated over all rows that refer to the same subject. The dimensionality of the data set can be confirmed by a call to the &lt;code&gt;dim()&lt;/code&gt; function, whilst the names of the 25 variables can be listed by a call to the &lt;code&gt;names()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dim(heart.valve)
## [1] 988  25
names(heart.valve)
##  [1] &amp;quot;num&amp;quot;          &amp;quot;sex&amp;quot;          &amp;quot;age&amp;quot;          &amp;quot;time&amp;quot;        
##  [5] &amp;quot;fuyrs&amp;quot;        &amp;quot;status&amp;quot;       &amp;quot;grad&amp;quot;         &amp;quot;log.grad&amp;quot;    
##  [9] &amp;quot;lvmi&amp;quot;         &amp;quot;log.lvmi&amp;quot;     &amp;quot;ef&amp;quot;           &amp;quot;bsa&amp;quot;         
## [13] &amp;quot;lvh&amp;quot;          &amp;quot;prenyha&amp;quot;      &amp;quot;redo&amp;quot;         &amp;quot;size&amp;quot;        
## [17] &amp;quot;con.cabg&amp;quot;     &amp;quot;creat&amp;quot;        &amp;quot;dm&amp;quot;           &amp;quot;acei&amp;quot;        
## [21] &amp;quot;lv&amp;quot;           &amp;quot;emergenc&amp;quot;     &amp;quot;hc&amp;quot;           &amp;quot;sten.reg.mix&amp;quot;
## [25] &amp;quot;hs&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will only analyse a subset of this data, namely records with case-complete data for heart valve gradient (&lt;code&gt;grad&lt;/code&gt;) and left ventricular mass index (&lt;code&gt;lvmi&lt;/code&gt;):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;hvd &amp;lt;- heart.valve[!is.na(heart.valve$grad) &amp;amp; !is.na(heart.valve$lvmi), ]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;model-fitting&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Model fitting&lt;/h2&gt;
&lt;p&gt;The main function in the &lt;code&gt;joineRML&lt;/code&gt; package is the &lt;code&gt;mjoint()&lt;/code&gt; function. Its main (required) arguments are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;formLongFixed&lt;/code&gt;: a list (of length equal to the number of longitudinal outcome types considered) of two-sided formulae specifying the response on the left-hand side and the mean linear predictor terms for the fixed effects in the linear mixed models on the right-hand side.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;formLongRandom&lt;/code&gt;: a list (of same length as &lt;code&gt;formLongFixed&lt;/code&gt;) of one-sided formulae specifying the model for random effects in the linear mixed models.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;formSurv&lt;/code&gt;: a formula specifying the proportional hazards regression model for the time-to-event outcome in the same structure as for &lt;code&gt;survival::coxph&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;data&lt;/code&gt;: a list (of same length as &lt;code&gt;formLongFixed&lt;/code&gt;) of data.frames; one for each longitudinal outcome. It is assumed that the event time data is in the first data.frame (i.e. &lt;code&gt;data[[1]]&lt;/code&gt;), unless the argument &lt;code&gt;survData&lt;/code&gt; (which defaults to &lt;code&gt;NULL&lt;/code&gt;) is specified. If &lt;span class=&#34;math inline&#34;&gt;\(K&amp;gt;1\)&lt;/span&gt; and the data are balanced within patients (i.e.Â multiple markers measured at common measurement times), then one can specify &lt;code&gt;data&lt;/code&gt; as a data frame rather than as a list.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;timeVar&lt;/code&gt;: the column name indicating the time variable in the linear mixed effects model. If &lt;span class=&#34;math inline&#34;&gt;\(K&amp;gt;1\)&lt;/span&gt; and the data frames have different column names for time, then &lt;code&gt;timeVar&lt;/code&gt; can alternatively be specified as a vector of strings of length &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can fit a bivariate joint model to the log-transformed valve gradient and LVMI indices in the &lt;code&gt;hvd&lt;/code&gt; subset using&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(12345)
fit &amp;lt;- mjoint(
  formLongFixed = list(&amp;quot;grad&amp;quot; = log.grad ~ time + sex + hs, 
                       &amp;quot;lvmi&amp;quot; = log.lvmi ~ time + sex),
  formLongRandom = list(&amp;quot;grad&amp;quot; = ~ 1 | num,
                        &amp;quot;lvmi&amp;quot; = ~ time | num),
  formSurv = Surv(fuyrs, status) ~ age,
  data = list(hvd, hvd),
  timeVar = &amp;quot;time&amp;quot;)
## Running multivariate LMM EM algorithm to establish initial parameters...
## Finished multivariate LMM EM algorithm...
## EM algorithm has converged!
## Estimating posterior random effects...
## Estimating approximate standard errors...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Details on the model estimation algorithm are provided in the technical details vignette. We note here that this is not necessarily the most appropriate model for the data, and is included only for the purposes of demonstration. There are a number of other useful arguments in the &lt;code&gt;mjoint&lt;/code&gt; function; for example, &lt;code&gt;inits&lt;/code&gt; for specifying (partial) initial values, &lt;code&gt;control&lt;/code&gt; for controlling the optimization algorithm, and &lt;code&gt;verbose&lt;/code&gt; for monitoring the convergence output in real-time. A full list of all arguments with explanation are given in the help documentation, accessed by running &lt;code&gt;help(&amp;quot;mjoint&amp;quot;)&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;post-fit-analysis&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Post-fit analysis&lt;/h2&gt;
&lt;p&gt;Once we have a fitted &lt;code&gt;mjoint&lt;/code&gt; object, we can begin to extract relevant information from it. Most summary statistics are available from the &lt;code&gt;summary&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(fit)
## 
## Call:
## mjoint(formLongFixed = list(grad = log.grad ~ time + sex + hs, 
##     lvmi = log.lvmi ~ time + sex), formLongRandom = list(grad = ~1 | 
##     num, lvmi = ~time | num), formSurv = Surv(fuyrs, status) ~ 
##     age, data = list(hvd, hvd), timeVar = &amp;quot;time&amp;quot;)
## 
## Data Descriptives:
## 
## Event Process
##     Number of subjects: 221 
##     Number of events: 47 (21.3%)
## 
## Longitudinal Process
##     Number of longitudinal outcomes: K = 2 
##     Number of observations:
##       Outcome 1 (grad): n = 629
##       Outcome 2 (lvmi): n = 629
## 
## Joint Model Summary:
## 
## Longitudinal Process: Multivariate linear mixed-effects model
##      log.grad ~ time + sex + hs, random = ~1 | num
##      log.lvmi ~ time + sex, random = ~time | num
## Event Process: Cox proportional hazards model
##      Surv(fuyrs, status) ~ age
## Model fit statistics:
##    log.Lik      AIC      BIC
##  -991.1275 2018.255 2079.422
## 
## Variance Components:
## 
## Random effects variance covariance matrix
##               (Intercept)_1 (Intercept)_2     time_2
## (Intercept)_1     0.1056400     0.0190870  0.0037087
## (Intercept)_2     0.0190870     0.1189100 -0.0062859
## time_2            0.0037087    -0.0062859  0.0024650
##   Standard Deviations: 0.32502 0.34484 0.049649 
## 
## Residual standard errors:
##  sigma2_1  sigma2_2 
## 0.5962153 0.1926125 
## 
## Coefficient Estimates:
## 
## Longitudinal sub-model:
##                       Value Std.Err  z-value p-value
## (Intercept)_1        2.5082  0.0642  39.0447 &amp;lt;0.0001
## time_1              -0.0044  0.0134  -0.3299  0.7415
## sex_1                0.1438  0.0769   1.8693  0.0616
## hsStentless valve_1  0.1883  0.0744   2.5319  0.0113
## (Intercept)_2        5.0895  0.0338 150.4384 &amp;lt;0.0001
## time_2              -0.0098  0.0068  -1.4390  0.1501
## sex_2               -0.1992  0.0550  -3.6228  0.0003
## 
## Time-to-event sub-model:
##          Value Std.Err z-value p-value
## age     0.1088  0.0160  6.7961 &amp;lt;0.0001
## gamma_1 1.5037  0.9032  1.6648  0.0959
## gamma_2 0.7982  0.6464  1.2349  0.2169
## 
## Algorithm Summary:
##     EM algorithm computational time: 40.5 secs 
##     Convergence status: converged
##     Convergence criterion: sas 
##     Final Monte Carlo sample size: 3122 
##     Standard errors calculated using method: approx&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One can also extract the coefficients, fixed effects, and random effects using standard generic functions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coef(fit)
## $D
##               (Intercept)_1 (Intercept)_2       time_2
## (Intercept)_1   0.105639552   0.019086970  0.003708682
## (Intercept)_2   0.019086970   0.118912598 -0.006285853
## time_2          0.003708682  -0.006285853  0.002465011
## 
## $beta
##       (Intercept)_1              time_1               sex_1 
##         2.508185353        -0.004409933         0.143812047 
## hsStentless valve_1       (Intercept)_2              time_2 
##         0.188281478         5.089519841        -0.009792227 
##               sex_2 
##        -0.199191133 
## 
## $sigma2
##   sigma2_1   sigma2_2 
## 0.35547268 0.03709956 
## 
## $haz
##  [1] 0.001870309 0.001877913 0.002021459 0.002229120 0.002264267
##  [6] 0.002340948 0.002397806 0.002401283 0.002438790 0.002454874
## [11] 0.002469187 0.002679255 0.002734533 0.002793430 0.002813763
## [16] 0.002848816 0.002899155 0.003034978 0.003167093 0.003374304
## [21] 0.003658375 0.007662982 0.004258645 0.004477425 0.004581532
## [26] 0.004773790 0.005186524 0.005315634 0.006235573 0.006769618
## [31] 0.006938246 0.007149842 0.007263083 0.007858815 0.008529241
## [36] 0.008891707 0.009245827 0.010046153 0.011935513 0.012311538
## [41] 0.013650072 0.016515164 0.017034515 0.046490600 0.048639295
## [46] 0.247497975
## 
## $gamma
##       age   gamma_1   gamma_2 
## 0.1088081 1.5036984 0.7982243
fixef(fit, process = &amp;quot;Longitudinal&amp;quot;)
##       (Intercept)_1              time_1               sex_1 
##         2.508185353        -0.004409933         0.143812047 
## hsStentless valve_1       (Intercept)_2              time_2 
##         0.188281478         5.089519841        -0.009792227 
##               sex_2 
##        -0.199191133
fixef(fit, process = &amp;quot;Event&amp;quot;)
##       age   gamma_1   gamma_2 
## 0.1088081 1.5036984 0.7982243
head(ranef(fit))
##   (Intercept)_1 (Intercept)_2      time_2
## 1   -0.20278045  -0.244812178 0.010415077
## 2   -0.04343910  -0.176953314 0.001840393
## 3   -0.01719138   0.006568905 0.010527853
## 4   -0.42634195  -0.596150071 0.012342804
## 5   -0.05144389   0.078210355 0.021558164
## 6    0.23251670   0.229308158 0.005302997&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although a model fit may indicate convergence, it is generally a good idea to examine the convergence plots. These can be viewed using the &lt;code&gt;plot&lt;/code&gt; function for each group of model parameters.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(fit, params = &amp;quot;gamma&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.glhickey.com/post/2017-02-17-using-joinerml/figures/hvd_model_conv-1.png&#34; width=&#34;696&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(fit, params = &amp;quot;beta&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://www.glhickey.com/post/2017-02-17-using-joinerml/figures/hvd_model_conv-2.png&#34; width=&#34;696&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bootstrap-standard-errors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Bootstrap standard errors&lt;/h2&gt;
&lt;p&gt;Once an &lt;code&gt;mjoint&lt;/code&gt; model has converged, and assuming the &lt;code&gt;se.approx&lt;/code&gt; argument is &lt;code&gt;TRUE&lt;/code&gt; (default), then approximated standard errors are calculated based on the empirical information matrix of the profile likelihood at the maximizer. Theoretically, these standard errors will be underestimated (see the technical vignette). In principle, residual Monte Carlo error will oppose this through an increase in uncertainty.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit.se &amp;lt;- bootSE(fit, nboot = 100)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bootstrapping is a computationally intensive method, possibly taking many hours to fit. For this reason, the &lt;code&gt;bootSE&lt;/code&gt; function makes use of the &lt;code&gt;use.mle&lt;/code&gt; argument, which automatically initializes each model fit to the maximizer of the fitted model, &lt;code&gt;fit&lt;/code&gt;. Also, one might relax the control parameter constraints on the optimization algorithm for each bootstrap model; however, this will be at the expense of inflated standard errors due to Monte Carlo error.&lt;/p&gt;
&lt;p&gt;Once we run &lt;code&gt;bootSE&lt;/code&gt;, we can call the object to interrogate it&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit.se&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or alternatively re-run the &lt;code&gt;summary&lt;/code&gt; command, passing the additional argument of &lt;code&gt;bootSE = fit.se&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(fit, bootSE = fit.se)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>

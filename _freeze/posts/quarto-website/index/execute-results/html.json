{
  "hash": "2be81e55e4e784f01b255211bb7279f4",
  "result": {
    "markdown": "---\ntitle: \"Quarto for Academic Websites\"\ndescription: |\n    I continue my life-long search for a system that will allow me to generate a nicely formatted\n    website and CV based on adding publications to one single source of truth.\ndate: \"2022-05-11\"\ncategories:\n  - website\ncode-fold: true\nexecute:\n    eval: false\nimage: /posts/quarto-website/tobias-meme.jpg\n---\n\nI've never been good at keeping my website updated. I always go through two different phases of maintenance:\n\n1. Rushing around creating a new website with bells and whistles\n2. Never updating an existing website\n\nI'm hoping to break out of this cycle, but am current in Phase 1. \nA highlight from my time in Phase 2 was when I forgot to update my DNS and I totally lost control of `drewdimmery.com` (don't go there, it has a squatter).\nI think my website at that time was some Octopress monstrosity\nThere are a few reasons I think [Quarto](https://quarto.org/) might help with this.\n\n- Serving static HTML pages is about as easy as it gets\n- Lots of flexibility (Python / R) in how to generate that content\n- Full programmability means that generation can be based on arbitrary data structures of my choosing\n\nThis post will detail how I've set up Quarto. I've nearly completely separated the two main concerns around maintaining an academic website / CV, which to me are data on *publications* and *software* from the design elements of how to display an atomic *publication* or *software package*.\n\n# Setup\n\nSetting up Quarto was very easy, so I won't belabor this. The combination of the [Get Started guide](https://quarto.org/docs/get-started/) with the [Website Creation guide](https://quarto.org/docs/websites/) kept everything very straightforward. I also used [Danielle Navarro's post](https://blog.djnavarro.net/posts/2022-04-20_porting-to-quarto/) and [her blog's code](https://github.com/djnavarro/quarto-blog).\n\nI decided late in the setup process to add a blog, so I will mention that it's actually very easy to do: it basically just requires adding a [Listing page](https://quarto.org/docs/reference/projects/websites.html#listings) (i.e. the blog's index), a folder to contain the various posts and a `_metadata.yml` file in that folder to describe global settings to apply to all posts. I just created these manually without too much trouble.\n\n# Site Design\n\nTo demonstrate how I've set things up to populate the website from data about my academic life, I'll focus on my [publications](/research.qmd) page. There are two main files undergirding this page:\n\n`papers.yaml`\n: a data file in YAML with standardized information on each publication. I chose YAML because it's fairly easy to write correctly formatted YAML by hand (and I'll be updating)\n\n`research.qmd`\n: The page which takes the data in `papers.yaml` and turns it into nicely formatted Markdown / HTML. This is setup as a Jupyter-backed `qmd` file (essentially a Jupyter notebook).\n\nThis idea of separating the data side (information about publications) and formatting is aimed at making my life easier. One of the reasons I often stop updating my website is because when I come back in 3 months with a new publication, I never remember all the details about how I formatted entries in whatever flavor of Bootstrap I happened to be using when I built the website.\n\nBy separating out the data entry from the formatting, this simplifies matters substantially.\n\nI previously used Hugo Academic for building my website, which was much better than just editing the markup directly, but I never remembered the right way to generate a new publication (there was a CLI, but I never remembered the syntax). Each publication got its own file describing its details, and I found this quite clunky. I wanted something extremely lightweight: there isn't much reason for my individual publications to get pages of their own. I just want some basic information about each of them and a set of appropriate links.\n\n## Data\n\nI put data about each publication in a basic YAML format:\n\n<details><summary>See example data</summary>\n\n```{yaml}\nsoftblock:\n  title: Efficient Balanced Treatment Assignments for Experimentation\n  authors:\n    - David Arbour\n    - me\n    - Anup Rao\n  year: 2021\n  venue: AISTATS\n  preprint: https://arxiv.org/abs/2010.11332\n  published_url: https://proceedings.mlr.press/v130/arbour21a.html\n  github: https://github.com/ddimmery/softblock\n```\n\n</details>\n\nThis is basically like a simplified bibtex entry with more URLs so I can annotate where to find replication materials for a given paper, as well as distinguish between preprints (always freely accessible) versus published versions (not always open access). A convenience that I add in the markup here is referring to myself as `me` in the author list (which is an ordered list). This allows me to add in extra post-processing to highlight where I sit in the author list.\n\nSome additional things I considered adding but chose to ignore for a first version:\n\n- An abstract\n- A suggested bibtex entry\n\nBoth of these would be easy to add, but I chose to start simpler. I also don't love YAML for entering long blocks of text.\n\n## Formatting\n\nSince I can write logic for a page in Python, this puts me on comfortable ground to hack something together. To knit the above publication data into HTML, I just literally bind together the programmatically generated raw HTML which should show up for a single entry.\n\nI do a couple additional useful things in this process:\n- Separate out working papers or non-archival papers from published work (I make this distinction based on whether I include a `published_url` field or not).\n- Order and categorize papers by year\n- Provide nice Bootstrappy buttons for external links (e.g. to Preprints / Code / etc)\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport yaml\nfrom IPython.display import display, Markdown, HTML\n\ndef readable_list(_s):\n  if len(_s) < 3:\n    return ' and '.join(map(str, _s))\n  *a, b = _s\n  return f\"{', '.join(map(str, a))}, and {b}\"\n\ndef button(url, str, icon):\n    icon_base = icon[:2]\n    return f\"\"\"<a class=\"btn btn-outline-dark btn-sm\", href=\"{url}\" target=\"_blank\" rel=\"noopener noreferrer\">\n        <i class=\"{icon_base} {icon}\" role='img' aria-label='{str}'></i>\n        {str}\n    </a>\"\"\"\n\nyaml_data = yaml.safe_load(open(\"papers.yaml\"))\npub_strs = {\"pubs\": {}, \"wps\": {}}\nfor _, data in yaml_data.items():\n    title_str = data[\"title\"]\n    authors = data.get(\"authors\", [\"me\"])\n    authors = [\n        aut if aut != \"me\" else \"<strong>Drew Dimmery</strong>\" for aut in authors\n    ]\n    author_str = readable_list(authors)\n    year_str = data[\"year\"]\n\n    buttons = []\n    preprint = data.get(\"preprint\")\n    if preprint is not None:\n        buttons.append(button(preprint, \"Preprint\", \"bi-file-earmark-pdf\"))\n\n    github = data.get(\"github\")\n    if github is not None:\n        buttons.append(button(github, \"Github\", \"bi-github\"))\n\n    pub_url = data.get(\"published_url\")\n    venue = data.get(\"venue\")\n    working_paper = pub_url is None\n    \n    pub_str = f'{author_str}. ({year_str}) \"{title_str}.\"'\n\n    if venue is not None:\n        pub_str += f\" <em>{venue}</em>\"\n\n    if working_paper:\n        if year_str not in pub_strs[\"wps\"]:\n            pub_strs[\"wps\"][year_str] = []\n        pub_strs[\"wps\"][year_str].append(\n            \"<li class='list-group-item'>\" + pub_str + \"<br>\" + \" \".join(buttons) + \"</li>\"\n        )\n    else:\n        if year_str not in pub_strs[\"pubs\"]:\n            pub_strs[\"pubs\"][year_str] = []\n        buttons.append(button(pub_url, \"Published\", \"ai-archive\"))\n        pub_strs[\"pubs\"][year_str].append(\n            \"<li class='list-group-item'>\" + pub_str + \"<br>\" + \" \".join(buttons) + \"</li>\"\n        )\n```\n:::\n\n\nI then print this out using the `display` functions from the IPython module and using the `asis` chunk option:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfor year in sorted(pub_strs[\"pubs\"].keys(), reverse=True):\n    display(Markdown(f\"### {year}\" + \"{#\" + f\"published-{year}\" + \"}\"))\n    display(HTML(\n        \"<ul class='list-group list-group-flush'>\" + '\\n'.join(pub_strs[\"pubs\"][year]) + \"</ul>\"\n    ))\n```\n:::\n\n\nThe [full code is on GitHub](https://github.com/ddimmery/quarto-website/blob/main/research.qmd).\n\nIt's worth noting that to get the years to show up in the Table of Contents its necessary to be careful exactly how the content is stuck onto the page. If you don't use the `asis` chunk option, you can still get all the right content to show up, but it won't necessarily appear in the ToC. It's also necessary to include `section-divs: false` in the header, or else the output will be wrapped in additional `div` tags which makes it harder to get the right classes in the right divs.\n\nI use the same basic setup to populate the [Software page](/software.qmd), albeit with simpler logic.\n\n### Additions\nI debated adding an abstract that expands out on click (like the code folding above in this post). This would actually be more or less trivial to add using a `<details>` HTML tag if I wanted to provide the data in the YAML. I'm ignoring this for now because I want to minimize data entry for my future self (and its anyway just a click away at the Preprint).\n\n# Deployment\n\nIt's extremely easy to build a new version of the website locally (`quarto render` from CLI), but there's no guarantee I'll remember that off the top of my head in a month without Googling, so I think it's worthwhile to setup automatic building after I push a commit to GitHub.\n\nGitHub Actions is incredible. I adapted the [example config from Quarto](https://github.com/quarto-dev/quarto-actions/blob/main/examples/quarto-book-netlify.yaml) to the following  (also [on GitHub here](https://github.com/ddimmery/quarto-website/blob/main/.github/workflows/build.yml)):\n\n<details><summary>GitHub Actions for Netlify</summary>\n\n```{yaml}\non:\n  push:\n    branches: main\n  pull_request:\n    branches: main\n  # to be able to trigger a manual build\n  workflow_dispatch:\n\nname: Render and deploy website to Netlify\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-python@v3\n        with:\n          python-version: '3.9'\n          cache: 'pip'\n      - run: pip install -r requirements.txt\n\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          use-public-rspm: true\n\n      - uses: r-lib/actions/setup-renv@v2\n      \n      - name: Install Quarto\n        uses: quarto-dev/quarto-actions/install-quarto@v1\n        with:\n          # To install LaTeX to build PDF book \n          tinytex: true \n          # uncomment below and fill to pin a version\n          # version: 0.9.105\n\n      - name: Render website\n        # Add any command line argument needed\n        run: |\n          quarto render\n      - name: Deploy to Netlify\n        id: netlify-deploy\n        uses: nwtgck/actions-netlify@v1\n        with:\n          # The folder the action should deploy. Adapt if you changed in Quarto config\n          publish-dir: './_site'\n          production-branch: main\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          deploy-message:\n            'Deploy from GHA: ${{ github.event.pull_request.title || github.event.head_commit.message }} (${{ github.sha }})'\n          enable-pull-request-comment: true #  Comment on pull request\n          enable-commit-comment: true # Comment on GitHub commit\n          enable-commit-status: true # GitHub commit status \n        env:\n          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}\n          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}\n        timeout-minutes: 1\n```\n\n</details>\n\nThis Action requires two pieces of information from Netlify entered as secrets in GitHub. The `NETLIFY_SITE_ID` may be found in the site configuration settings, while the `NETLIFY_AUTH_TOKEN` may be found in personal settings (the personal access token).\n\nSetting this up means that simple updates to pages can actually be done directly in the GitHub editing UI, which further lowers the barrier for my future self. I don't even need to clone the repository to whatever computer I'm working on!\n\n# Future dreams\n\n## Combined CV + Website\nI imagine my CV is similar to most academics' in that it's built like a house of cards (and overfull hboxs). Whenever I add something new to it, I have to copy some lines from elsewhere and modify them to fit the new entry. This always takes me way more time than I'd like. If I mashed together my current [About page](/about.qmd) with the [Research page](/research.qmd), it's like 90% of the way to a full CV. It should presumably be pretty easy to do this explicitly and output a reasonable-looking CV. \n\nThis is a project for another day, though. Too much of the Research page directly outputs HTML, which makes it difficult to naively import into a $\\LaTeX$ CV.\n\nAn almost completely naïve approach to directly importing the relevant pages creates [this ugly document](cv.pdf).\n\n<details><summary>Naïve CV</summary>\n\n```{markdown}\n---\ntitle: \"Curriculum Vitae\"\nformat: pdf\n---\n\n{{< include about.qmd >}}\n\n{{< include research.md >}}\n```\n\n</details>\n\nIt's definitely possible to improve on this. The easiest hacky approach is to just write a whole alternative version of the formatting code which resides in `research.qmd` to output appropriately formatted $\\LaTeX$ markup.\n\n# Conclusion\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}